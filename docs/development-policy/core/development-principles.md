# 開発原則

## 基本理念

### 1. ユーザーファースト
- **使いやすさ優先**: 機能の充実より直感的なUI/UX
- **パフォーマンス重視**: レスポンス時間 < 200ms（95パーセンタイル）
- **アクセシビリティ**: 多様なユーザーが利用可能な設計

### 2. 非公式プロジェクトとしての責任
- **透明性**: 非公式であることを常に明示
- **敬意**: 公式コンテンツへの配慮と著作権尊重
- **節度**: 営利目的ではないファン活動としての位置づけ

### 3. 持続可能な開発
- **シンプルさ**: 複雑さより保守性を優先
- **段階的改善**: 完璧を求めず、継続的な改良
- **ドキュメント重視**: 将来の自分・他者のための記録

## 開発アプローチ

### 1. 段階的リリース（Incremental Release）
```
MVP (v0.1) → 基本機能 (v1.0) → 拡張機能 (v1.x) → コミュニティ機能 (v2.0)
```

**原則**:
- 各段階で動作する製品をリリース
- ユーザーフィードバックを次段階に反映
- 過度な機能追加より安定性を重視

### 2. ドメイン駆動設計（DDD）
**コア概念**:
- カード（Card）: ゲームの基本単位
- デッキ（Deck）: 戦略の表現
- プレイヤー（Player）: システム利用者

**境界づけられたコンテキスト**:
1. **カード管理**: マスターデータの管理
2. **デッキ構築**: プレイヤーの創造性支援
3. **コミュニティ**: 情報共有と交流

### 3. データ最小化原則
**方針**:
- 必要最小限のデータのみ収集・保存
- プライバシーファーストの設計
- 不要になったデータの自動削除

## コーディング原則

### 1. 読みやすさ優先
```typescript
// ❌ 悪い例：過度に短縮された変数名
const d = cs.map(c => ({ i: c.id, n: c.name }));

// ✅ 良い例：意図が明確な命名
const deckCards = cardService.map(card => ({
  id: card.id,
  name: card.name
}));
```

### 2. 早期リターン
```typescript
// ❌ 悪い例：ネストが深い
function validateDeck(deck: Deck) {
  if (deck) {
    if (deck.cards.length >= 30) {
      if (deck.cards.length <= 40) {
        return true;
      }
    }
  }
  return false;
}

// ✅ 良い例：早期リターンでフラット
function validateDeck(deck: Deck) {
  if (!deck) return false;
  if (deck.cards.length < 30) return false;
  if (deck.cards.length > 40) return false;
  return true;
}
```

### 3. 型安全性の徹底
```typescript
// ❌ 悪い例：any型の使用
function processData(data: any) {
  return data.value;
}

// ✅ 良い例：明確な型定義
interface ProcessableData {
  value: string;
  metadata?: Record<string, unknown>;
}

function processData(data: ProcessableData): string {
  return data.value;
}
```

## エラーハンドリング原則

### 1. ユーザーフレンドリーなエラー
```typescript
// ❌ 悪い例：技術的なエラー
throw new Error('ECONNREFUSED: Connection refused');

// ✅ 良い例：ユーザー向けメッセージ
throw new UserError(
  'サーバーに接続できません。しばらくしてから再度お試しください。',
  'CONNECTION_ERROR'
);
```

### 2. エラーの分類
1. **ユーザーエラー**: 入力ミスなど（400番台）
2. **システムエラー**: サーバー側の問題（500番台）
3. **ネットワークエラー**: 接続問題
4. **検証エラー**: データ不整合

### 3. ログとモニタリング
- エラーは必ずログに記録
- ユーザー情報は含めない
- スタックトレースは開発環境のみ

## テスト原則

### 1. テストピラミッド
```
         /\
        /  \  E2E Tests (10%)
       /----\
      /      \ Integration Tests (30%)
     /--------\
    /          \ Unit Tests (60%)
```

### 2. テスト可能な設計
- 依存性注入（DI）の活用
- モックしやすいインターフェース
- 純粋関数の推奨

### 3. テストの品質
- Arrange-Act-Assert パターン
- 1テスト1検証
- 意味のあるテスト名

## チーム開発原則

### 1. コミュニケーション
- **非同期優先**: ドキュメントとコメントで情報共有
- **透明性**: 進捗と課題の可視化
- **建設的**: 批判より改善提案

### 2. コードレビュー
- **目的**: 品質向上と知識共有
- **焦点**: ロジック > スタイル
- **態度**: 学習機会として活用

### 3. 責任の共有
- **集団所有**: 全員がコード全体に責任
- **ペアプログラミング**: 複雑な実装時に推奨
- **知識の文書化**: 属人化の防止

## 意思決定プロセス

### 1. 技術選定基準
1. **実績**: 本番環境での使用実績
2. **保守性**: 長期的なメンテナンス可能性
3. **学習曲線**: チームの習得コスト
4. **エコシステム**: ツール・ライブラリの充実度

### 2. 機能追加基準
1. **ユーザー価値**: 実際のニーズの有無
2. **実装コスト**: 開発・保守の負担
3. **整合性**: 既存機能との調和
4. **リスク**: セキュリティ・パフォーマンスへの影響

### 3. 変更管理
- すべての変更は Issue 起票から開始
- 大きな変更は RFC（Request for Comments）作成
- 後方互換性の維持を原則とする

## まとめ

これらの原則は絶対的なものではなく、プロジェクトの成長とともに進化すべきものです。重要なのは、チーム全体で価値観を共有し、一貫性のある開発を行うことです。